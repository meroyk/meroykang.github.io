<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SSL-1 | meroykang</title>
<link rel="shortcut icon" href="https://meroykang.github.io/favicon.ico?v=1669386424492">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://meroykang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="SSL-1 | meroykang - Atom Feed" href="https://meroykang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="ecure Sockets Layer
SSL协议概述
SSL解决的问题（功能）
协议的使用
SSL在协议栈的位置
SSL协议的分层模型
SSL体系结构
SSL的两个重要概念
主要工作流程
SSL握手协议的握手过程
SSL记录层的功能
SS..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://meroykang.github.io">
  <img class="avatar" src="https://meroykang.github.io/images/avatar.png?v=1669386424492" alt="">
  </a>
  <h1 class="site-title">
    meroykang
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="https://github.com/meroyk/meroykang.github.io/tags" class="menu" target="_blank">
          网络安全
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              SSL-1
            </h2>
            <div class="post-info">
              <span>
                2022-11-25
              </span>
              <span>
                7 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>ecure Sockets Layer<br>
SSL协议概述<br>
SSL解决的问题（功能）<br>
协议的使用<br>
SSL在协议栈的位置<br>
SSL协议的分层模型<br>
SSL体系结构<br>
SSL的两个重要概念<br>
主要工作流程<br>
SSL握手协议的握手过程<br>
SSL记录层的功能<br>
SSL协议脆弱性分析<br>
SSL协议概述<br>
Secure Sockets Layer 安全套接字协议</p>
<p>鉴于SSL协议的脆弱性 升级出了它的爸爸TSL 所以Wrieshark抓不出SSL以前的数据包</p>
<p>TLS(Transport Layer Security)是更为安全的升级版 SSL。</p>
<p>SSL协议可用于保护正常运行于TCP之上的任何应用协议，如HTTP、FTP、SMTP或Telnet的通信，最常见的是用SSL来保护HTTP的通信。</p>
<p>SSL协议的优点在于它是与应用层协议无关的。高层的应用协议（如HTTP、FTP、Telnet等）能透明地建立于SSL协议之上。</p>
<p>SSL协议在应用层协议之前就已经完成加密算法、通信密钥的协商以及服务器的认证工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的安全性。</p>
<p>SSL解决的问题（功能）<br>
客户对服务器的身份认证<br>
SSL服务器允许客户的浏览器使用标准的公钥加密技术和一些可靠的认证中心（CA）的证书，来确认服务器的合法性。</p>
<p>服务器对客户的身份认证<br>
也可通过公钥技术和证书进行认证，也可通过用户名，password来认证。</p>
<p>建立服务器与客户之间安全的数据通道<br>
SSL要求客户与服务器之间的所有发送的数据都被发送端加密、接收端解密，同时还检查数据的完整性</p>
<p>协议的使用<br>
https://</p>
<p>SSL在协议栈的位置</p>
<p>SSL协议的分层模型<br>
SSL协议是一个分层的协议，共有两层组成。处于SSL协议的底层的是SSL记录层协议(SSL Record Protocol)，它位于可靠的传输层协议(如TCP)之上，用于封装高层协议的数据。其中SSL握手协议(SSL Handshake Protocol)允许服务方和客户方互相认证，并在应用层协议传送数据之前协商出一个加密算法和会话密钥。</p>
<p>SSL体系结构</p>
<p>SSL的两个重要概念<br>
SSL连接（connection)<br>
一个连接是一个提供一种合适类型服务的传输（OSI分层的定义）。<br>
SSL的连接是点对点的关系。<br>
连接是暂时的，每一个连接和一个会话关联。</p>
<p>SSL会话（session）<br>
一个SSL会话是在客户与服务器之间的一个关联。会话由Handshake Protocol创建。会话定义了一组可供多个连接共享的密码安全参数。<br>
会话用以避免为每一个连接提供新的安全参数所需昂贵的协商代价。</p>
<p>主要工作流程<br>
1.网络连接建立，SSL客户端发送消息，消息中包含SSL版本号、密码设置、可实现的算法列表、随机数以及服务器使用SSL协议通信所需的其它信息；<br>
2.SSL服务器端回应消息，确定SSL版本号、加密算法和压缩算法；<br>
3.SSL服务器发出服务器数字证书；<br>
4.SSL客户端的身份认证是可选的；<br>
5.客户端生成预主密钥pre_master_secret，用服务器的公钥加密后返回服务器，服务器利用自己的私钥解密后得到会话密钥；<br>
5. 若服务器要求客户认证，客户机会向服务器随加密的pre_master_secret一起发送签名的数据和客户自己的证书。<br>
7. 服务器若认证客户成功，使用私钥加密pre_master_secret，然后执行一系列步骤生成master secret。否则会话终止。<br>
8. 客户机与服务器使用master secret生成会话密钥。该密钥是对称密钥，用于加密和解密在SSL会话期间交换的信息，检验信息完整性。<br>
9. CS：发送消息通知以后从客户机来的消息将用会话密钥加密。客户机然后发送一条独立的（加密的）消息表明握手的客户机部分已经完成。</p>
<p>应用数据的传输过程为 :<br>
１)应用程序把应用数据提交给本地的SSL；<br>
２)发送端的SSL根据需要 ：<br>
a)使用指定的压缩算法 ，压缩应用数据；<br>
b)使用散列算法对压缩后的数据计算散列值；<br>
c)把散列值和压缩数据一起用加密算法加密；<br>
3) 密文通过网络传给对方；<br>
4)接收方的SSL<br>
用相同的加密算法对密文解密 ，得到明文；<br>
用相同的散列算法对明文中的应用数据散列；<br>
计算得到的散列值与明文中的散列值比较；<br>
5）如果一致 ,则明文有效 ,接收方的SSL把明文解压后得到应用数据上交给应用层。否则就丢弃数据，并向发方发出告警信息。严重的错误有可能引起再次的协商或连接中断。</p>
<p>SSL握手协议的握手过程<br>
无客户端认证的全握手过程</p>
<p>有客户端认证的全握手过程</p>
<p>会话恢复过程</p>
<p>SSL记录层的功能<br>
保护传输数据的私密性，对数据进行加密和解密<br>
验证传输数据的完整性，计算报文的摘要<br>
提高传输数据的效率，对报文进行压缩<br>
保证数据传输的可靠和有序<br>
报文格式</p>
<p>SSL协议脆弱性分析<br>
客户端假冒</p>
<p>因为SSL协议设计初衷是对Web站点及网上交易进行安全性保护，使消费者明白正在和谁进行交易要比使商家知道谁正在付费更为重要，为了不致于由于安全协议的使用而导致网络性能大幅下降， SSL协议并不是默认地要求进行客户鉴别，这样做虽然有悖于安全策略，但却促进了SSL的广泛应用。</p>
<p>针对这个问题，可在必要的时候配置SSL协议，使其选择对客户端进行认证鉴别。</p>
<p>无法保护UDP应用</p>
<p>SSL协议需要在握手之前建立TCP连接，因此不能对UDP应用进行保护。如果要兼顾UDP协议层之上的安全保护，可以采用IP层的安全解决方案。<br>
SSL协议不能对抗流量分析</p>
<p>由于SSL只对应用数据进行保护，数据包的IP头和TCP头仍然暴露在外，通过检查没有加密的IP源和目的地址以及TCP端口号或者检查通信数据量，一个通信分析者依然可以揭示哪一方在使用什么服务，有时甚至揭露商业或私人关系的秘密。<br>
进程中主密钥泄漏</p>
<p>除非SSL的工程实现大部分驻留在硬件中，否则主密钥将会存留在主机的主存储器中，这就意味着任何可以读取SSL进程存储空间的攻击者都能读取主密钥，因此，不可能面对掌握机器管理特权的攻击者而保护SSL连接，这个问题要依靠用户管理策略来解决。<br>
————————————————<br>
版权声明：本文为CSDN博主「李白你好」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_44309905/article/details/116453443</p>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://meroykang.github.io/post/hello-gridea/">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://meroykang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
